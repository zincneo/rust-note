#![allow(dead_code)]
/**
# 所有权原则

- Rust通过编译器检查变量的使用是否符合所有权的原则来实现内存管理
- 核心原则为以下三条
  1. Rust中每一个值都必须被变量拥有，该变量称为该值的所有者
  2. 一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者
  3. 当所有者（变量）离开作用域范围时，这个值将被丢弃(drop)
- 由于编译器会自己检查应该何时drop数据，因此即不需要手动分配内存，运行时也不需要垃圾回收
*/
pub fn f01_ownership() {
    {
        // s 在这里无效，它尚未声明
        let s = String::from("hello"); // 从此处起，s 是有效的
        // 使用 s
        println!("{s}");
    } // 此作用域已结束，s不再有效
}

/**
# 数据绑定
- Rust中称=运算符为数据绑定，含义是将内存中的某一个值绑定到一个变量上
- 在数据绑定的时候会依据值的不同(在堆上还是栈上)发生以下三种行为
  - 对于栈上的数据发生Copy(中文经常叫做浅拷贝)，直接复制一份值
  - 对于堆上的数据发生Move行为，将值绑定到新的变量上，这时候原来的变量将不能再次使用
  - 对于堆上的数据发生Clone(中文经常叫做深拷贝)
    - 堆上开出一块新的空间拷贝原来堆上的值
    - 然后变量绑定到一个新的栈上数据(包含指向这个新的堆位置)
    - Rust不会主动发生深拷贝，触发深拷贝需要代码控制，通常是堆上数据类型会提供clone方法
*/
pub fn f02_data_bind() {
    // 1. copy
    let n = 10;
    let _n = n;

    // 2. move
    let n = String::from("rust");
    let _n = n; // 移动之后n将不能再次使用

    // 3. clone
    let n = String::from("rust");
    let _n = n.clone(); // clone方法会在堆上发生深拷贝，发生深拷贝之后n和_n都可以使用
}
