/*!
# ch03 Rust所有权

## 00 背景知识

### 堆和栈

计算机程序在运行时，分配变量通常在两个区域，堆区和栈区
1. 栈区(stack)
    - 栈本身是指先进后出的数据结构
    - 内存的栈区通常用来存放局部变量和函数调用上下文，由编译器/操作系统分配给应用程序不需要手动管理内存
    - 内存的栈区要求放置的数据必须是大小已知的(编译期)
    - 内存的栈区大小有限(Rust主线程可以使用8Mb其他线程为2Mb)
2. 堆区(heap)
    - 堆本身是指类似完全二叉树的数据结构
    - 内存的堆区是用户可以手动分配的内存，编程的时候需要进行内存管理
    - 内存的堆区可以存放未知大小(编译期)的数据
    - 内存的堆区较大，通常是物理内存还剩下多大空间可以使用就可以使用多少

### 内存管理

所有的程序都必须和计算机内存打交道，如何从内存中申请空间来存放程序的运行内容，如何在不需要的时候释放这些空间，成了重中之重，也是所有编程语言设计的难点之一。在计算机语言不断演变过程中，出现了三种流派：
1. 垃圾回收机制(Garbage Collection, GC):代表语言Java和Golang
2. 手动控制内存分配和释放:代表语言c/c++
3. 所有权原则，编译器在编译期根据一系列规则进行检查:代表语言Rust，c++中有类似的RAII编程范式(思想类似但并非编译器实现的核心规则)

### 堆栈性能差异

在栈上分配内存比在堆上分配内存要快，因为入栈时操作系统无需进行函数调用（或更慢的系统调用）来分配新的空间，只需要将新数据放入栈顶即可。相比之下，在堆上分配内存则需要更多的工作，这是因为操作系统必须首先找到一块足够存放数据的内存空间，接着做一些记录为下一次分配做准备，如果当前进程分配的内存页不足时，还需要进行系统调用来申请更多内存。 因此，处理器在栈上分配数据会比在堆上分配数据更加高效。

## 01 所有权

1. [所有权原则](./ch03_01_ownership/fn.f01_ownership.html)
2. [数据绑定](./ch03_01_ownership/fn.f02_data_bind.html)

### 所有权解决的内存泄漏问题

c语言中存在的悬垂指针问题
```c
int* foo() {
    int a;          // 变量a的作用域开始
    a = 100;
    char *c = "xyz";   // 变量c的作用域开始
    return &a;
}                   // 变量a和c的作用域结束
```
以上代码中变量 a 和 c 都是局部变量，函数结束后将局部变量 a 的地址返回，但局部变量 a 存在栈中，在离开作用域后，a 所申请的栈上内存都会被系统回收，从而造成了 悬空指针(Dangling Pointer) 的问题。这是一个非常典型的内存安全问题，虽然编译可以通过，但是运行的时候会出现错误，很多编程语言都存在。

再来看变量 c，c 的值是常量字符串，存储于常量区，可能这个函数我们只调用了一次，也可能我们不再会使用这个字符串，但 "xyz" 只有当整个程序结束后系统才能回收这片内存。

Rust通过所有权原则，在编译期就可以检查出这些问题，如果返回一个已经被drop的变量的引用(见02 引用和借用)那么编译器就会直接报错不允许通过编译

## 02 引用和借用

1. [引用和解引用](./ch03_02_reference/fn.f01_ref.html)
2. [可变引用](./ch03_02_reference/fn.f02_mut_ref.html)
3. 借用规则总结
    1. 同一个时刻，只能有一个可变引用或者任意个不可变引用
    2. 引用必须总是有效的(即借用的变量被drop的时候引用自动无效不可使用)
*/

pub mod ch03_01_ownership;
pub mod ch03_02_reference;

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn ch03_01() {
        assert_eq!(ch03_01_ownership::f01_ownership(), ());
        assert_eq!(ch03_01_ownership::f02_data_bind(), ());
    }

    #[test]
    fn ch03_02() {
        assert_eq!(ch03_02_reference::f01_ref(), ());
        assert_eq!(ch03_02_reference::f02_mut_ref(), ());
    }
}
