#![allow(dead_code)]
#![allow(unused)]

/**
# 生命周期
- 生命周期设计的目的之一是通过编译器检查来避免悬垂指针问题
- 编译器会分析合法的引用变量可使用的范围
- 对于局部变量无法使用生命周期标识符，因为编译器很明确地知道其生命周期应该跟随哪个变量
*/
pub fn f01_lifetime() {
    let r;

    {
        let x = 5;
        r = &x; // 编译其很明确引用变量r的生命周期应该跟随x
    }
    // x被Drop，r的生命周期也结束，不可以再使用
    // println!("r: {}", r); // 导致编译报错，r引用的变量x已经被销毁了
    // 不合法的r在编译期就可以通过生命周期检查发现，对比C来说，C的编译器没有这种检查
}

/**
# 函数参数中的生命周期
- 需要生命周期标识符的场景一定是返回值是引用类型
    - 引用类型才会涉及到返回值是否会变成悬垂指针的问题
    - 其他类型通过所有权和Drop规则编译器已经能处理好使用的合法性
- 使用生命周期标识符之前必须在泛型参数列表中先声明该标识符
- 对于函数体内，生命周期的来源只能存在两种可能
    1. 跟随参数的生命周期
    2. 函数体内部的局部变量
- 当编译器可以推导出来生命周期的时候，就不需要手动标注生命周期标识符
- 生命周期标识符的消除规则
    1. 每一个引用参数都会获得独自的生命周期(来自调度的时候引用的变量的生命周期)
    2. **若只有一个输入生命周期（函数参数中只有一个引用类型），那么该生命周期会被赋给所有的输出生命周期**，也就是所有返回值的生命周期都等于该输入生命周期
    3. 若存在多个输入生命周期，且其中一个为`&self`或者`&mut self`，则`&self`的生命周期赋给所有输出生命周期，这条归结见下一小节
*/
pub fn f02_function() {
    // 1. 手动标注生命周期
    fn f01<'a>(input: &'a String) -> &'a String {
        input
    }
    // 2. 上面的例子只有一个输入生命周期，因此'a可以被编译器推导出来，可以不写
    fn f02(input: &String) -> &String {
        input
    }
    // 3. 有多个生命周期的情况，且不符合消除原则编译器推导不出来返回值的生命周期，这时候需要手动标明生命周期标识符
    fn f03<'a, 'b>(a: &'a mut String, b: &'b mut String) -> &'b mut String {
        b.push_str(a.as_str());
        b
    }
    fn f04<'a>(a: &'a str, b: &'a str) -> &'a str {
        if a.len() > b.len() { a } else { b }
    }
    // 4. 多个输入生命周期的函数，编译器无法推导出来返回值生命周期，必须要标注生命周期标识符，否则无法通过编译
    /*
    fn f05(a: &str, b: &str) -> &str {
        if a.len() > b.len() { a } else { b }
    }
    */
}
