/*!
# ch03 Rust所有权

## 00 背景知识

### 堆和栈

计算机程序在运行时，分配变量通常在两个区域，堆区和栈区
1. 栈区(stack)
  - 栈本身是指先进后出的数据结构
  - 内存的栈区通常用来存放局部变量和函数调用上下文，由编译器/操作系统分配给应用程序不需要手动管理内存
  - 内存的栈区要求放置的数据必须是大小已知的(编译期)
  - 内存的栈区大小有限(Rust主线程可以使用8Mb其他线程为2Mb)
2. 堆区(heap)
  - 堆本身是指类似完全二叉树的数据结构
  - 内存的堆区是用户可以手动分配的内存，编程的时候需要进行内存管理
  - 内存的堆区可以存放未知大小(编译期)的数据
  - 内存的堆区较大，通常是物理内存还剩下多大空间可以使用就可以使用多少

### 内存管理

所有的程序都必须和计算机内存打交道，如何从内存中申请空间来存放程序的运行内容，如何在不需要的时候释放这些空间，成了重中之重，也是所有编程语言设计的难点之一。在计算机语言不断演变过程中，出现了三种流派：
1. 垃圾回收机制(Garbage Collection, GC):代表语言Java和Golang
2. 手动控制内存分配和释放:代表语言c/c++
3. 所有权原则，编译器在编译期根据一系列规则进行检查:代表语言Rust，c++中有类似的RAII编程范式(思想类似但并非编译器实现的核心规则)

### 堆栈性能差异

在栈上分配内存比在堆上分配内存要快，因为入栈时操作系统无需进行函数调用（或更慢的系统调用）来分配新的空间，只需要将新数据放入栈顶即可。相比之下，在堆上分配内存则需要更多的工作，这是因为操作系统必须首先找到一块足够存放数据的内存空间，接着做一些记录为下一次分配做准备，如果当前进程分配的内存页不足时，还需要进行系统调用来申请更多内存。 因此，处理器在栈上分配数据会比在堆上分配数据更加高效。

## 01 所有权

1. [所有权原则](./fn.f01_01_ownership.html)
2. [数据绑定规则](./fn.f01_02_data_bind.html)

## 02 引用和借用

*/

/**
# 所有权原则

- Rust通过编译器检查变量的使用是否符合所有权的原则来实现内存管理
- 核心原则为以下三条
  1. Rust中每一个值都必须被变量拥有，该变量称为该值的所有者
  2. 一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者
  3. 当所有者（变量）离开作用域范围时，这个值将被丢弃(drop)
- 由于编译器会自己检查应该何时drop数据，因此即不需要手动分配内存，运行时也不需要垃圾回收
- 以下代码使用标准库中的String类型(内存在堆上)演示
```rust
    {
        // s 在这里无效，它尚未声明
        let s = String::from("hello"); // 从此处起，s 是有效的
        // 使用 s
        println!("{s}");
    } // 此作用域已结束，s不再有效
```
*/
pub fn f01_01_ownership() {
    {
        // s 在这里无效，它尚未声明
        let s = String::from("hello"); // 从此处起，s 是有效的
                                       // 使用 s
        println!("{s}");
    } // 此作用域已结束，s不再有效
}

/**
# 数据绑定
- Rust中称=运算符为数据绑定，含义是将内存中的某一个值绑定到一个变量上
- 在数据绑定的时候会依据值的不同(在堆上还是栈上)发生以下三种行为
  - 对于栈上的数据发生Copy(中文经常叫做浅拷贝)，直接复制一份值
  - 对于堆上的数据发生Move行为，将值绑定到新的变量上，这时候原来的变量将不能再次使用
  - 对于堆上的数据发生Clone(中文经常叫做深拷贝)
    - 堆上开出一块新的空间拷贝原来堆上的值
    - 然后变量绑定到一个新的栈上数据(包含指向这个新的堆位置)
    - Rust不会主动发生深拷贝，触发深拷贝需要代码控制，通常是堆上数据类型会提供clone方法
```rust
    // 1. copy
    let n = 10;
    let _n = n;

    // 2. move
    let n = String::from("rust");
    let _n = n; // 移动之后n将不能再次使用

    // 3. clone
    let n = String::from("rust");
    let _n = n.clone(); // clone方法会在堆上发生深拷贝，发生深拷贝之后n和_n都可以使用
```

*/
pub fn f01_02_data_bind() {
    // 1. copy
    let n = 10;
    let _n = n;

    // 2. move
    let n = String::from("rust");
    let _n = n; // 移动之后n将不能再次使用

    // 3. clone
    let n = String::from("rust");
    let _n = n.clone(); // clone方法会在堆上发生深拷贝，发生深拷贝之后n和_n都可以使用
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn ch03_01() {
        assert_eq!(f01_01_ownership(), ());
        assert_eq!(f01_02_data_bind(), ());
    }
}
