/*!
# ch03 Rust所有权

## 00 背景知识

### 堆和栈

计算机程序在运行时，分配变量通常在两个区域，堆区和栈区
1. 栈区(stack)
    - 栈本身是指先进后出的数据结构
    - 内存的栈区通常用来存放局部变量和函数调用上下文，由编译器/操作系统分配给应用程序不需要手动管理内存
    - 内存的栈区要求放置的数据必须是大小已知的(编译期)
    - 内存的栈区大小有限(Rust主线程可以使用8Mb其他线程为2Mb)
2. 堆区(heap)
    - 堆本身是指类似完全二叉树的数据结构
    - 内存的堆区是用户可以手动分配的内存，编程的时候需要进行内存管理
    - 内存的堆区可以存放未知大小(编译期)的数据
    - 内存的堆区较大，通常是物理内存还剩下多大空间可以使用就可以使用多少

### 内存管理

所有的程序都必须和计算机内存打交道，如何从内存中申请空间来存放程序的运行内容，如何在不需要的时候释放这些空间，成了重中之重，也是所有编程语言设计的难点之一。在计算机语言不断演变过程中，出现了三种流派：
1. 垃圾回收机制(Garbage Collection, GC):代表语言Java和Golang
2. 手动控制内存分配和释放:代表语言c/c++
3. 所有权原则，编译器在编译期根据一系列规则进行检查:代表语言Rust，c++中有类似的RAII编程范式(思想类似但并非编译器实现的核心规则)

### 堆栈性能差异

在栈上分配内存比在堆上分配内存要快，因为入栈时操作系统无需进行函数调用（或更慢的系统调用）来分配新的空间，只需要将新数据放入栈顶即可。相比之下，在堆上分配内存则需要更多的工作，这是因为操作系统必须首先找到一块足够存放数据的内存空间，接着做一些记录为下一次分配做准备，如果当前进程分配的内存页不足时，还需要进行系统调用来申请更多内存。 因此，处理器在栈上分配数据会比在堆上分配数据更加高效。

## 01 所有权

1. [所有权原则](./fn.f01_01_ownership.html)
2. [数据绑定](./fn.f01_02_data_bind.html)

### 所有权解决的内存泄漏问题

c语言中存在的悬垂指针问题
```c
int* foo() {
    int a;          // 变量a的作用域开始
    a = 100;
    char *c = "xyz";   // 变量c的作用域开始
    return &a;
}                   // 变量a和c的作用域结束
```
以上代码中变量 a 和 c 都是局部变量，函数结束后将局部变量 a 的地址返回，但局部变量 a 存在栈中，在离开作用域后，a 所申请的栈上内存都会被系统回收，从而造成了 悬空指针(Dangling Pointer) 的问题。这是一个非常典型的内存安全问题，虽然编译可以通过，但是运行的时候会出现错误，很多编程语言都存在。

再来看变量 c，c 的值是常量字符串，存储于常量区，可能这个函数我们只调用了一次，也可能我们不再会使用这个字符串，但 "xyz" 只有当整个程序结束后系统才能回收这片内存。

Rust通过所有权原则，在编译期就可以检查出这些问题，如果返回一个已经被drop的变量的引用(见02 引用和借用)那么编译器就会直接报错不允许通过编译

## 02 引用和借用

1. [引用和解引用](./fn.f02_01_ref.html)
2. [可变引用](./fn/f02_02_mut_ref.html)
3. 借用规则总结
    1. 同一个时刻，只能有一个可变引用或者任意个不可变引用
    2. 引用必须总是有效的(即借用的变量被drop的时候引用自动无效不可使用)
*/

/**
# 所有权原则

- Rust通过编译器检查变量的使用是否符合所有权的原则来实现内存管理
- 核心原则为以下三条
  1. Rust中每一个值都必须被变量拥有，该变量称为该值的所有者
  2. 一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者
  3. 当所有者（变量）离开作用域范围时，这个值将被丢弃(drop)
- 由于编译器会自己检查应该何时drop数据，因此即不需要手动分配内存，运行时也不需要垃圾回收
- 以下代码使用标准库中的String类型(内存在堆上)演示
```rust
    {
        // s 在这里无效，它尚未声明
        let s = String::from("hello"); // 从此处起，s 是有效的
        // 使用 s
        println!("{s}");
    } // 此作用域已结束，s不再有效
```
*/
pub fn f01_01_ownership() {
    {
        // s 在这里无效，它尚未声明
        let s = String::from("hello"); // 从此处起，s 是有效的
                                       // 使用 s
        println!("{s}");
    } // 此作用域已结束，s不再有效
}

/**
# 数据绑定
- Rust中称=运算符为数据绑定，含义是将内存中的某一个值绑定到一个变量上
- 在数据绑定的时候会依据值的不同(在堆上还是栈上)发生以下三种行为
  - 对于栈上的数据发生Copy(中文经常叫做浅拷贝)，直接复制一份值
  - 对于堆上的数据发生Move行为，将值绑定到新的变量上，这时候原来的变量将不能再次使用
  - 对于堆上的数据发生Clone(中文经常叫做深拷贝)
    - 堆上开出一块新的空间拷贝原来堆上的值
    - 然后变量绑定到一个新的栈上数据(包含指向这个新的堆位置)
    - Rust不会主动发生深拷贝，触发深拷贝需要代码控制，通常是堆上数据类型会提供clone方法
```rust
    // 1. copy
    let n = 10;
    let _n = n;

    // 2. move
    let n = String::from("rust");
    let _n = n; // 移动之后n将不能再次使用

    // 3. clone
    let n = String::from("rust");
    let _n = n.clone(); // clone方法会在堆上发生深拷贝，发生深拷贝之后n和_n都可以使用
```
*/
pub fn f01_02_data_bind() {
    // 1. copy
    let n = 10;
    let _n = n;

    // 2. move
    let n = String::from("rust");
    let _n = n; // 移动之后n将不能再次使用

    // 3. clone
    let n = String::from("rust");
    let _n = n.clone(); // clone方法会在堆上发生深拷贝，发生深拷贝之后n和_n都可以使用
}

/**
# 引用
- Rust中通过借用来避免所有权转移导致代码复杂度上升
- 获取变量的引用，称之为借用(borrowing)
- 引用(reference)和借用(borrowing)就是一回事，Rust又拿了个新词表述罢了
- 在变量名前面加上&即可获得该变量的借用
- 常规引用是一个指针类型，指向了对象存储的内存地址
- 使用let ref_variable = &variable_name，可以获取变量的引用，*borrowing_name可以解除引用获取值
- 另外一种获取引用的方式是定义变量的时候使用ref关键字，这时候不能加上&运算符
- &variable_name称为不可变的引用，无法通过引用修改变量的值
- 不可变引用可以同时存在多个
```rust
    let num = 30;
    let r_num = &num;
    let ref _r_num = num; // 可以同时存在多个不可变引用
    assert_eq!(num, *r_num);
```
```rust
// 利用不可变引用传递变量，避免所有权转移
fn calculate_length(s: &String) -> usize {
    s.len()
}
```
*/
pub fn f02_01_ref() {
    let num = 30;
    let r_num = &num;
    let ref _r_num = num; // 可以同时存在多个不可变引用
    assert_eq!(num, *r_num);
}

/**
# 可变引用
- `let ref_variable = &mut variable_name`称为获取一个变量的可变引用
- 另外一种形式为`let ref mut ref_variable = variable_name;
- 可变引用同一时刻只能存在一个，且不可以和不可变引用同时存在
- 注意当前编译器版本下，引用作用域的结束位置从花括号变成最后一次使用的位置
```rust
    let mut num = 100;
    let ref mut r_num = num;
    *r_num += 10;
    println!("{r_num}");
```
*/
pub fn f02_02_mut_ref() {
    let mut num = 100;
    let ref mut r_num = num;
    *r_num += 10;
    println!("{r_num}");
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn ch03_01() {
        assert_eq!(f01_01_ownership(), ());
        assert_eq!(f01_02_data_bind(), ());
    }

    #[test]
    fn ch03_02() {
        assert_eq!(f02_01_ref(), ());
        assert_eq!(f02_02_mut_ref(), ());
    }
}
